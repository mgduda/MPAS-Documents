\documentclass[11pt]{report}

\usepackage{epsf,amsmath,amsfonts}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{color}

\setlength{\topmargin}{0in}
\setlength{\headheight}{0in}
\setlength{\headsep}{0in}
\setlength{\textheight}{9.0in}
\setlength{\textwidth}{6.5in}
\setlength{\evensidemargin}{0in}
\setlength{\oddsidemargin}{0in}

\begin{document}

\title{Generic Variable and Option Collections}
\author{}

\maketitle
\tableofcontents


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Introduction
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}

Future plans call for an MPAS framework that permits multiple MPAS cores to be compiled into a single executable. In order to achieve this goal,
the MPAS infrastructure must be free from namespace conflicts in all data structures that it provides for a core. The objective of this document is to develop 
requirements and a design for core-independent data structures that will be used to store run-time configuration (i.e., namelist) options, fields, and groups of fields. 

To illustrate the problem with the current framework, consider that at present, the MPAS ocean core may define a field group (known within the MPAS Registry as a {\em var\_struct}) called `state' that contains the fields `temperature', `salinity', and `ssh':


\begin{lstlisting}[language=fortran,escapechar=@,frame=single]
type state_type
	type (field2dReal), pointer :: temperature
	type (field2dReal), pointer :: salinity
	type (field1dReal), pointer :: ssh
end type state_type
\end{lstlisting}

\noindent On the other hand, the MPAS atmosphere core also defines a field group called `state' that instead contains the fields `theta', `rho', and `u':

\begin{lstlisting}[language=fortran,escapechar=@,frame=single]
type state_type
	type (field2dReal), pointer :: theta
	type (field2dReal), pointer :: rho
	type (field2dReal), pointer :: u
end type state_type
\end{lstlisting}

\noindent When only one core is compiled into an executable, the current infrastructure is able to accommodate the differences in the contents of the field structures by generating different definitions of, e.g., the derived type `state\_type' that contains the fields in the `state' group. However, such conflicting definitions of a derived type would clearly preclude the compilation of two or more MPAS cores at the same time. 

This document proposes generic variable collections and option collections as a solution to the issue of namespace conflicts in field and option storage. These generic collections are envisioned as data types that can be instantiated multiple times, with each instance made to contain an independent, arbitrary set of fields or set of options. We recognize that there exist other approaches to resolving namespace conflicts among cores --- one such approach involves modifying the {\em Registry} program to generate data structures whose names are specific to a particular core, e.g., 'ocn\_state\_type' and 'atm\_state\_type' in the case of the ocean and atmosphere state variable groups mentioned above --- however, based on discussions, generic data types were identified as the most elegant solution among all those considered, and will be the focus of this proposal.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Requirements
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Requirements}
 
We require the following from generic data structures for representing collections of fields (e.g., `theta', `salinity'), field groups (e.g., `mesh', `state'), and configuration options (e.g., `config\_dt`, `config\_apvm\_upwinding`). Note, however, that we propose separate data structures for fields, field groups, and options; supporting all three types within a single data structure is considered infeasible.

\section{Requirement: Core-independence}

Any definitions of Fortran derived types for representing collections of fields, field groups, or options must not contain information that is specific to any particular MPAS core. This implies that resolving namespace conflicts by, e.g., creating a field collection that contains the union of all fields in all MPAS cores or by creating uniquely named types for each MPAS core (`ocn\_state\_type' and `atm\_state\_type' as in the Introduction) is ruled out. 

\section{Requirement: Detection of erroneous usage}

Generic collection types should allow developers to trap --- either at run-time or at compile-time --- errors in field, field group, or option references that can be caught by compiler errors or run-time checks in the current MPAS code. Primarily, errors that are caught at compile time include references to fields that have not been defined in the Registry.xml file, e.g., 

\newpage
\begin{lstlisting}[language=fortran,escapechar=@,frame=single]
real (kind=RKIND), dimension(:,:), pointer :: foo

! A compile-time error occurs if foo has not been defined 
!    in the Registry as part of mesh
foo => mesh % foo % array
\end{lstlisting}

\noindent and errors that are caught at run-time include uses of unassociated (null) field and array pointers, e.g.,

\begin{lstlisting}[language=fortran,escapechar=@,frame=single]
real (kind=RKIND), dimension(:,:), pointer :: foo

! A run-time pointer error occurs if foo is not set to a field array
! foo => mesh % foo % array

foo(:,:) = 3.14159265
\end{lstlisting}

\noindent . 

\section{Requirement: Discoverable contents}

Since a field collection may contain an arbitrary set of fields, subroutines that need to perform operations on groups of fields (e.g., registration with an I/O stream) must be provided with a mechanism for discovering which fields are contained in a collection and ultimately retrieving those fields; the same requirement holds for field groups and for configuration options.

\section{Requirement: Negligible performance impact}

Since the retrieval of field and array pointers, and namelist options, takes place many times throughout the execution of an MPAS core, changing the storage of collections of fields and configuration options has the potential to significantly impact the computational performance of MPAS. The use of generic data structures should lead to no more than a 0.1\% increase in runtime for current MPAS cores.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Design
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Design}

TBD


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Testing
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Testing}

\section{No change to results}

TBD

\section{Performance}

TBD

\section{Error detection}

TBD

%-----------------------------------------------------------------------

\end{document}
